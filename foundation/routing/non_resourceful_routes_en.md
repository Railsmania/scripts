[wip]
# Non-Resourceful Routes
In addition to resource routing, Rails has powerful support for routing arbitrary URLs to actions. Here, you don't get groups of routes automatically generated by resourceful routing. Instead, you set up each route within your application separately.

While you should usually use resourceful routing, there are still many places where the simpler routing is more appropriate. There's no need to try to shoehorn every last piece of your application into a resourceful framework if that's not a good fit.

In particular, simple routing makes it very easy to map legacy URLs to new Rails actions.

3.1 Bound Parameters
When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming HTTP request. Two of these symbols are special: :controller maps to the name of a controller in your application, and :action maps to the name of an action within that controller. For example, consider this route:

get ':controller(/:action(/:id))'
If an incoming request of /photos/show/1 is processed by this route (because it hasn't matched any previous route in the file), then the result will be to invoke the show action of the PhotosController, and to make the final parameter "1" available as params[:id]. This route will also route the incoming request of /photos to PhotosController#index, since :action and :id are optional parameters, denoted by parentheses.

3.2 Dynamic Segments
You can set up as many dynamic segments within a regular route as you like. Anything other than :controller or :action will be available to the action as part of params. If you set up this route:

get ':controller/:action/:id/:user_id'
An incoming path of /photos/show/1/2 will be dispatched to the show action of the PhotosController. params[:id] will be "1", and params[:user_id] will be "2".

You can't use :namespace or :module with a :controller path segment. If you need to do this then use a constraint on :controller that matches the namespace you require. e.g:

get ':controller(/:action(/:id))', controller: /admin\/[^\/]+/
By default, dynamic segments don't accept dots - this is because the dot is used as a separator for formatted routes. If you need to use a dot within a dynamic segment, add a constraint that overrides this – for example, id: /[^\/]+/ allows anything except a slash.

3.3 Static Segments
You can specify static segments when creating a route by not prepending a colon to a fragment:

get ':controller/:action/:id/with_user/:user_id'
This route would respond to paths such as /photos/show/1/with_user/2. In this case, params would be { controller: 'photos', action: 'show', id: '1', user_id: '2' }.

3.4 The Query String
The params will also include any parameters from the query string. For example, with this route:

get ':controller/:action/:id'
An incoming path of /photos/show/1?user_id=2 will be dispatched to the show action of the Photos controller. params will be { controller: 'photos', action: 'show', id: '1', user_id: '2' }.

3.5 Defining Defaults
You do not need to explicitly use the :controller and :action symbols within a route. You can supply them as defaults:

get 'photos/:id', to: 'photos#show'
With this route, Rails will match an incoming path of /photos/12 to the show action of PhotosController.

You can also define other defaults in a route by supplying a hash for the :defaults option. This even applies to parameters that you do not specify as dynamic segments. For example:

get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }
Rails would match photos/12 to the show action of PhotosController, and set params[:format] to "jpg".

3.6 Naming Routes
You can specify a name for any route using the :as option:

get 'exit', to: 'sessions#destroy', as: :logout
This will create logout_path and logout_url as named helpers in your application. Calling logout_path will return /exit

You can also use this to override routing methods defined by resources, like this:

get ':username', to: 'users#show', as: :user
This will define a user_path method that will be available in controllers, helpers and views that will go to a route such as /bob. Inside the show action of UsersController, params[:username] will contain the username for the user. Change :username in the route definition if you do not want your parameter name to be :username.

3.7 HTTP Verb Constraints
In general, you should use the get, post, put, patch and delete methods to constrain a route to a particular verb. You can use the match method with the :via option to match multiple verbs at once:

match 'photos', to: 'photos#show', via: [:get, :post]
You can match all verbs to a particular route using via: :all:

match 'photos', to: 'photos#show', via: :all
Routing both GET and POST requests to a single action has security implications. In general, you should avoid routing all verbs to an action unless you have a good reason to.

3.8 Segment Constraints
You can use the :constraints option to enforce a format for a dynamic segment:

get 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\d{5}/ }
This route would match paths such as /photos/A12345, but not /photos/893. You can more succinctly express the same route this way:

get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/
:constraints takes regular expressions with the restriction that regexp anchors can't be used. For example, the following route will not work:

get '/:id', to: 'posts#show', constraints: {id: /^\d/}
However, note that you don't need to use anchors because all routes are anchored at the start.

For example, the following routes would allow for posts with to_param values like 1-hello-world that always begin with a number and users with to_param values like david that never begin with a number to share the root namespace:

get '/:id', to: 'posts#show', constraints: { id: /\d.+/ }
get '/:username', to: 'users#show'
3.9 Request-Based Constraints
You can also constrain a route based on any method on the Request object that returns a String.

You specify a request-based constraint the same way that you specify a segment constraint:

get 'photos', constraints: {subdomain: 'admin'}
You can also specify constraints in a block form:

namespace :admin do
  constraints subdomain: 'admin' do
    resources :photos
  end
end
3.10 Advanced Constraints
If you have a more advanced constraint, you can provide an object that responds to matches? that Rails should use. Let's say you wanted to route all users on a blacklist to the BlacklistController. You could do:

class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

Rails.application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: BlacklistConstraint.new
end
You can also specify constraints as a lambda:

Rails.application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: lambda { |request| Blacklist.retrieve_ips.include?(request.remote_ip) }
end
Both the matches? method and the lambda gets the request object as an argument.

3.11 Route Globbing and Wildcard Segments
Route globbing is a way to specify that a particular parameter should be matched to all the remaining parts of a route. For example:

get 'photos/*other', to: 'photos#unknown'
This route would match photos/12 or /photos/long/path/to/12, setting params[:other] to "12" or "long/path/to/12". The fragments prefixed with a star are called "wildcard segments".

Wildcard segments can occur anywhere in a route. For example:

get 'books/*section/:title', to: 'books#show'
would match books/some/section/last-words-a-memoir with params[:section] equals 'some/section', and params[:title] equals 'last-words-a-memoir'.

Technically, a route can have even more than one wildcard segment. The matcher assigns segments to parameters in an intuitive way. For example:

get '*a/foo/*b', to: 'test#index'
would match zoo/woo/foo/bar/baz with params[:a] equals 'zoo/woo', and params[:b] equals 'bar/baz'.

By requesting '/foo/bar.json', your params[:pages] will be equals to 'foo/bar' with the request format of JSON. If you want the old 3.0.x behavior back, you could supply format: false like this:

get '*pages', to: 'pages#show', format: false
If you want to make the format segment mandatory, so it cannot be omitted, you can supply format: true like this:

get '*pages', to: 'pages#show', format: true
3.12 Redirection
You can redirect any path to another path using the redirect helper in your router:

get '/stories', to: redirect('/posts')
You can also reuse dynamic segments from the match in the path to redirect to:

get '/stories/:name', to: redirect('/posts/%{name}')
You can also provide a block to redirect, which receives the symbolized path parameters and the request object:

get '/stories/:name', to: redirect {|path_params, req| "/posts/#{path_params[:name].pluralize}" }
get '/stories', to: redirect {|path_params, req| "/posts/#{req.subdomain}" }
Please note that this redirection is a 301 "Moved Permanently" redirect. Keep in mind that some web browsers or proxy servers will cache this type of redirect, making the old page inaccessible.

In all of these cases, if you don't provide the leading host (http://www.example.com), Rails will take those details from the current request.

3.13 Routing to Rack Applications
Instead of a String like 'posts#index', which corresponds to the index action in the PostsController, you can specify any Rack application as the endpoint for a matcher:

match '/application.js', to: Sprockets, via: :all
As long as Sprockets responds to call and returns a [status, headers, body], the router won't know the difference between the Rack application and an action. This is an appropriate use of via: :all, as you will want to allow your Rack application to handle all verbs as it considers appropriate.

For the curious, 'posts#index' actually expands out to PostsController.action(:index), which returns a valid Rack application.

3.14 Using root
You can specify what Rails should route '/' to with the root method:

root to: 'pages#main'
root 'pages#main' # shortcut for the above
You should put the root route at the top of the file, because it is the most popular route and should be matched first.

The root route only routes GET requests to the action.

You can also use root inside namespaces and scopes as well. For example:

namespace :admin do
  root to: "admin#index"
end

root to: "home#index"
3.15 Unicode character routes
You can specify unicode character routes directly. For example:

get 'こんにちは', to: 'welcome#index'
